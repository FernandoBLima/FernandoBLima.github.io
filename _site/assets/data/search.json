[
  
  {
    "title"    : "Graph - Data Structure &amp; Algorithm Part VIII",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2020/12/28/data-structure-part-VIII.html",
    "date"     : "December 28, 2020",
    "excerpt"  : "Hello everyone, today I intend to continue this series that we discussed data structure and for this post we will learn graphs. This incredible structure you can apply to many problems in the real world, so it is one of the most important structur...",
  "content"  : "Hello everyone, today I intend to continue this series that we discussed data structure and for this post we will learn graphs. This incredible structure you can apply to many problems in the real world, so it is one of the most important structures and also very common in interview questions.\n\n\nSo, let‚Äôs dive into this new adventure!\n\n\n  üí≠ ‚ÄúThe trick is to fix the problem you have, rather than the problem you want.‚Äù - Bram Cohen\n\n\nOutline\n\n  What is a Graph?\n  Basic concepts.\n  The main operations and properties.\n  Learning BFS and DFS functions.\n\n\nGraph\n\nMany people often confuse a graph with a tree structure, and that‚Äôs happened because a tree is a type of graph!\n\n\n\nBasically, a graph is a non-linear structure of a set of vertices V connected by edges E that can be represented as ordered pair of vertices G(V,E) .\n\nMore precisely, a graph is composed of paths that contain adjacency vertices connected by edges. Usually, you can find many books and articles using different terms to refer to vertices and edges, the most common of which are:\n\n\n  Vertex: Nodes or points;\n  Edges: Lines, links or arcs;\n\n\n‚ñ™Ô∏è Graph visualization\n\nOne of the most interesting things that make graphs a powerful structure is how they can represent a lot of information for some applications. There are many examples that we can use and the most common are a network of cities, streets, flights, ferries, railway maps, social network connections, and so on‚Ä¶\n\nFrom theses examples, a graph structure can obtain a lot of information, such as how many cities are close to another or which is the sort path between two cities, for example. Can you see how powerful this structure can be?\n\nEven though a graph is just a collection of nodes and edges, there are two ways to represent it, which are:\n\n\n  Adjacency Matrices\n\n\nAs the name suggests, this representation uses a square matrix where rows and columns mean that there is a relationship from one vertex to another. We can see how it works in the image below.\n\n\n\nFigure 1: Adjacency Matrice visualization.\n\nAs we can see, the matrix represents which vertices are connected by edges, we can simply find out if there is a relationship between the vertices looking at the matrix.\n\n\n  Adjacency List\n\n\nIs the most common and efficient way to represent a graph, because creates an array that can store all vertices in a list for each vertex of the graph. Using the same set used in the adjacency matrix above:\n\n\n\nFigure 2: Adjacency list visualization.\n\n‚ñ™Ô∏è Graph Representations\n\nAfter talking about visualizations, the next step is to learn how many types of graph exists. Here we will see how the vertices are organized and connected.\n\nDirected or undirected\n\n\n  Directed\n\n\nIn this type of graph, the edges are directed from one vertex to another. As we can see, the edge between 0 and 1 vertices is directed, right?\n\n\n\nFigure 3: Directed graph representation.\n\n\n  Undirected\n\n\nUnlike the directed graph, this type of graph has all vertices pointing towards each other, that is, all edges are bidirectional.\n\n\n\nFigure 4: Undirected graph representation.\n\n\n  Cyclic or acyclic\n\n\nA cycle graph means if the graph contains a path that begins at a given vertex and after few vertices ends at the same starting vertex. The example below contains the following cycle: 5 -&amp;gt; 2 -&amp;gt; 1 -&amp;gt; 4.\n\n\n\nFigure 5: Cyclic graph representation.\n\n‚ñ™Ô∏è Basic operations\n\nOkay, now that we already understand what a graph is, let‚Äôs see how to implement it. First thing first, we need to create our main class and, as we have seen, there are two ways to build this structure and will use the adjacency list representation, where a key and all its connections are associated.\n\nLet‚Äôs see how below:\n\nclass Graph {\n    constructor() {\n        this.adjacencyList = {}\n    }\n    ...\n\n}\n\n\nSimple right? üòÅ We just need to initialize the adjacencyList variable that will be used as a dictionary to add key-value pairs. The next step is to know how to insert a vertex in our graph using the dictionary that was created.\n\nWhen a new vertex is added to the structure, it takes only a constant time, the time complexity of O(1). This is because we just need to add the new element to the array.\n\nGreat! Moving forward, we need to use a real-world example to facilitate our understanding and we will use a social network to exemplify operations.\n\naddVertex(vertex){\n    this.adjacencyList[vertex] = [];\n} \n\n\nA social network needs some users, right? So, let‚Äôs fill it out by adding some people from middle-earth using the following code:\n\nconst middle_earth = new Graph();\n\nmiddle_earth.addVertex(&#39;Gandalf&#39;);\nmiddle_earth.addVertex(&#39;Saruman&#39;)\nmiddle_earth.addVertex(&#39;Frodo&#39;)\nmiddle_earth.addVertex(&#39;Billy&#39;)\nmiddle_earth.addVertex(&#39;Sean&#39;)\nmiddle_earth.addVertex(&#39;Merry&#39;)\nmiddle_earth.addVertex(&#39;Sm√©agol&#39;)\n\n\nWell, something is missing from our social network. We need interactions between the users, the next step is to create some connections between the vertices created.\n\nAs discussed earlier, the main differences between these types of graphs are in the fact that only the undirected function creates connections on both sides.\n\nThe code below shows how we can create connections using directed and undirected approaches.\n\naddEdgeDirected(vertex1, vertex2) { \n    if(!this.adjacencyList[vertex1]){\n       this.addVertex(vertex1)\n    }\n    if(!this.adjacencyList[vertex2]){\n       this.addVertex(vertex2)\n    }\n\n    if(!this.adjacencyList[vertex1].includes(vertex2))\n        this.adjacencyList[vertex1].push(vertex2);   \n}\n\naddEdgeUndirected(vertex1, vertex2) { \n    if(!this.adjacencyList[vertex1]){\n        this.addVertex(vertex1)\n    }\n    if(!this.adjacencyList[vertex2]){\n        this.addVertex(vertex2)\n    }\n    \n    if(!this.adjacencyList[vertex1].includes(vertex2))\n        this.adjacencyList[vertex1].push(vertex2);    \n\n    if(!this.adjacencyList[vertex2].includes(vertex1))\n        this.adjacencyList[vertex2].push(vertex1); \n}\n\n\nIn this example of social networking, we will use the undirected approach, however, the directed type graph also can be used. Moving on, let‚Äôs now imagine that Gandalf added some hobbits and a wizard to his social network.\n\nmiddle_earth.addEdgeUndirected(&#39;Gandalf&#39;, &#39;Billy&#39;);\nmiddle_earth.addEdgeUndirected(&#39;Gandalf&#39;, &#39;Merry&#39;)\nmiddle_earth.addEdgeUndirected(&#39;Gandalf&#39;, &#39;Sean&#39;)\nmiddle_earth.addEdgeUndirected(&#39;Gandalf&#39;, &#39;Frodo&#39;)\nmiddle_earth.addEdgeUndirected(&#39;Gandalf&#39;, &#39;Saruman&#39;)\n\n\nAfter that, our graph looks something like this:\n\n\n\nFigure 6: Middle-earth network representation.\n\nAwesome! üòÅ\n\nOkay, moving forward with the discussion, let‚Äôs imagine the scenario where the Sm√©agol user had a bad behaviour and it is necessary to removed it, how we can do this?\n\n\n\nFor now, we have no way to remove any vertex. So, we need to fix this, right? To delete a vertex from the graph, it is necessary to iterate through the list of each vertex and validate whether an edge exists or not. If it exists, then we have to remove the vertex. Let‚Äôs take a look:\n\nremoveVertex(vertex) { \n    if(vertex in this.adjacencyList){\n        delete this.adjacencyList[vertex];\n        var vertexList = Object.keys(this.adjacencyList);\n        vertexList.forEach(element =&amp;gt; {\n            if(this.adjacencyList[element].includes(vertex) == true){\n                var index = this.adjacencyList[element].indexOf(vertex);\n                this.adjacencyList[element].splice(index,1);\n            }\n        });\n    }\n}\n\nAs you may be thinking, this function is O(n) because we need to iterate over the vertices and then remove the element.\n\nAnd the edges? I mean, what if Gandalf had a big argument with Saruman and then decides to remove him from his social network? What do we have to do? üßê Well, to remove an edge, we need to check if the vertices are connected and then remove from the array.\n\nremoveEdge(vertex1, vertex2) { \n    if(this.adjacencyList[vertex1].includes(vertex2)){\n        var adjacents = this.adjacencyList[vertex1];\n        var index = adjacents.indexOf(vertex2);\n        this.adjacencyList[vertex1] = adjacents.splice(index,1);\n    }\n}\n\n\nGreat! Can you see the progress? üöÄ\n\nThere are functions like print_all_path_destination, print_adjacency_matrix, countPaths, isAdjacent and others that I would like to discuss, but I‚Äôll skip the explanations for not taking too much of your time.\n\n\n  ‚ö°Ô∏è But if you would like to learn or see others functions that I implemented you can access all the code just clicking here.\n\n\nNow we are going to use all the acknowledgement that we learned to implement search function.\n\n‚ñ™Ô∏è Graph Search\n\nLet‚Äôs dive into the most important topic related to this structure! We want to traverse all the vertices and edges of that graph. What does that mean? Well, we can put an example: Gandalf had a map and try to travel across middle-earth. üòÅ But relax, we‚Äôll see all the steps of these functions using an example along the way. Let‚Äôs create a graph to be used.\n\nvar graph_example = new Graph();\ngraph_example.addEdgeDirected(0, 1)\ngraph_example.addEdgeDirected(0, 2)\ngraph_example.addEdgeDirected(1, 3)\ngraph_example.addEdgeDirected(1, 4)\ngraph_example.addEdgeDirected(2, 5)\ngraph_example.addEdgeDirected(2, 6)\n\n\nAfter creating the vertices and edges, our graph will look something like this:\n\n\n\nFigure 7: Graph example to be used on BFS and DFS functions.\n\n\n  Breadth-first search (BFS)\n\n\nThis approach is the most common and used. It starts by considering all vertices as unvisited and all edges undiscovered. With that in mind, we can choose an arbitrary vertex and then discover all vertices connected by an edge and visited.\n\nEvery time that an adjacent vertex is visited, we must mark it and insert it in a queue. Since none of the edges that incident on the vertex are undiscovered, we can proceed and explore the next vertex.\n\nUsing the example above and considering vertex 0 as the current vertex, the result is:\n\nVisited Vertex: 0\nVisited Vertex: 1\nVisited Vertex: 2\nVisited Vertex: 3\nVisited Vertex: 4\nVisited Vertex: 5\nVisited Vertex: 6\n\n\nWe must repeat the process until no undiscovered and unvisited are left in the structure. When the queue is empty, it means that the algorithm covers all vertices and edges. With all that in mind, let‚Äôs put everything in a code.\n\nbreadthFirstSearch(current_vertice) {\n    var vertices = Object.keys(this.adjacencyList);\n    if(vertices.length === 0){\n        return;\n    }else {\n        var discovered = {};\n        vertices.forEach(function(item) {\n            discovered[item] = false;\n        })\n        this._breadthFirstSearch(current_vertice, discovered);\n    }\n}\n\n_breadthFirstSearch(vertex, discovered){\n    var queue = [];\n    discovered[vertex] = true;\n    queue.push(vertex);\n\n    while(queue.length &amp;gt; 0){\n        var u = queue.shift();\n        console.log(&#39;Visited Vertex: &#39; + u);\n\n        var listAdjacents = this.adjacencyList[u].sort((a, b) =&amp;gt; a - b)\n        listAdjacents = listAdjacents.sort()\n\n        for (let index = 0; index &amp;lt; listAdjacents.length; index++) {\n            const element = listAdjacents[index];\n            if(!discovered[element]){\n                discovered[element] = true;\n                queue.push(element);\n            }\n        }\n    }\n}\n\n\n\n  Depth First Search (DFS)\n\n\nInitially, this function has conditions similar to the BFS function, all vertices are unvisited and edges are not discovered. Then, we can choose an arbitrary vertex that will be our root element, which will be visited and called the current vertex.\n\nNow is when the difference between DFS and BFS functions begins! The current vertex has to explore as far as possible along each vertex visited, moving to the next undiscovered adjacent edge and printing the path.\n\nWe must continue this loop until there are no unvisited and undiscovered elements. Instead of queuing, the DFS function uses a stack to find the shortest path. After that, with no undiscovered edges left, we have to go back to the initial visited vertex and start again checking other unvisited vertices until cover all vertices and edges of the graph.\n\nUsing vertex 0 as the current vertex, we will obtain the following result:\n\nVisited Vertex  0\nVisited Vertex  1\nVisited Vertex  3\nVisited Vertex  4\nVisited Vertex  2\nVisited Vertex  5\nVisited Vertex  6\n\n\ndepthFirstSearch(current_vertice) {\n    var vertices = Object.keys(this.adjacencyList);\n    if(vertices.length === 0){\n        return;\n    }\n    var discovered = {};\n    vertices.forEach(function(item) {\n        discovered[item] = false;\n    })\n    this._depthFirstSearch(current_vertice, discovered);\n}\n\n_depthFirstSearch(current_vertice, discovered){\n    discovered[current_vertice] = true;\n    console.log(&#39;Visited Vertex &#39;, current_vertice);\n    \n    var listAdjacents = this.dictAdj[current_vertice].sort((a, b) =&amp;gt; a - b)\n    for (let index = 0; index &amp;lt; listAdjacents.length; index++) {\n        const element = listAdjacents[index];\n        if(!discovered[element]){\n            this._depthFirstSearch(element, discovered);\n        }\n    }\n}\n\n\n\n\nThat‚Äôs all folks!\n\nI hope you have fun learning. üòÅ\n\n\n\nCode: https://github.com/FernandoBLima/data-structures\n___\n\nSo we finished our discussion about Graph structure. üôå\n\nIf you found something I miss out or find this article helpful, feel free to let me know. üòÅ\n"
} ,
  
  {
    "title"    : "Heap - Data Structure &amp; Algorithm Part VII",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2020/12/13/data-structure-part-VII.html",
    "date"     : "December 13, 2020",
    "excerpt"  : "It‚Äôs been a while since the last post in this series. I was very busy with other things, but I‚Äôm back! Yes! üòÅ In this post, we will continue to learn a new data structure and how to implement it. üë®‚Äçüíªüë©‚Äçüíª\n\n\n\n\n  üí≠  ‚ÄúFalling in love with code means fa...",
  "content"  : "It‚Äôs been a while since the last post in this series. I was very busy with other things, but I‚Äôm back! Yes! üòÅ In this post, we will continue to learn a new data structure and how to implement it. üë®‚Äçüíªüë©‚Äçüíª\n\n\n\n\n  üí≠  ‚ÄúFalling in love with code means falling in love with problem solving and being a part of a forever ongoing conversation. To be a computer programmer does not mean to live in isolation and solitude, but rather the exact opposite.‚Äù - Kathryn Barrett\n\n\n\n\nOutline\n\n  What is a Heap?\n  Basic concepts\n  The main operations and properties.\n\n\nLet‚Äôs start to work! üòÉ\n\n‚óºÔ∏è Trie\n\n\n  Pre-requisite : Tree\n\n\n\n  If you haven‚Äôt read tree and binary search tree, I recommend you check it out first!\n\n\n- What is a Heap? üßê\n\nIf you‚Äôve seen how the heap structure organizes values, you might think that there are some similarities to the tree structure. Yes, indeed. Basically, we can define a heap structure as a special full binary tree structure where each element has exactly two children, the only exception can be the deepest level.\n\nOne important thing to keep in mind about this structure is that there are two types of heap and the differences between them are related to the property of storing a value, which can be:\n\n\n  Max-heap: The root element has the maximum value and the value for every element is equal or greater than the value in the node‚Äôs children.\n\n\n\n\nFigure 1: Max-heap representation.\n\n\n  Min-heap: Here we have the opposite side because the root element has the minimum value and the value for every element is equal to or less than the value in the node‚Äôs children.\n\n\n\n\nFigure 2: Min-heap representation.\n\nAs we can see, every element can be actually called as the root of its own sub-heap. For instance, using min-heap example given above we can say that the value 8 is the root of 7 and 3 sub-heap.\n\n\n\nFigure 3: Example of sub-heap.\n\nAfter describing the basics and understanding what the heap is, how do we create this data structure? First things first, let‚Äôs start building the constructor.\n\nSo, you may be thinking and assuming based on the last post about tree structure that we could implement a simple class that contains left and right elements, right? üßê\n\nYou are absolutely right! üòÉ We can certainly implement it that way, however, there is another and better approach that we can use to create an efficient way of implementing it.\n\n\n\nInstead of creating these elements, we can use an array to store all the heap values, simple right? In this way, we just need to store all the values top to bottom, left to right, and that‚Äôs it! Using this approach, we can know that the fifth value in the array will be the fifth value in the heap, for instance.\n\nLet‚Äôs use the min-heap example used above and take a look at the following image:\n\n\n\nFigure 3: Array-heap representation.\n\nThe use of array indexes can describe the parent-child structure. But, wait! ‚úã What that‚Äôs mean? ü§î Looking at the element, we can get the left child element by Arr[(2*i)+1] that returns the value. And the parent and right element? Let‚Äôs take a look below:\n\n\n  Index of element = i\n  Returns the left child element = Arr[(2*i)+1]\n  Returns the right child element = Arr[(2*i)+2]\n  Returns the parent element = Arr[i/2]\n\n\nFor example, let‚Äôs use the value X in the array, which is  the third element of the structure. To get the parent value, we just have to get the index value and divided it by 2. Simple right? That said, understanding how we can access these values will be extremely important in the next function in the heap structure.\n\nNow that we‚Äôre on the same page, let‚Äôs move on and put everything that we‚Äôve learned into our code. First, we need to create the skeleton of our heap class.\n\nclass Heap {\n\n    constructor() {\n        this.list = [];\n    }\n    ...\n}\n\n\nBasic operations\n\nOkay, now that we already know how to build the heap structure let‚Äôs diving into the main operations.\n\nTalk is cheap. Show me the code! üòÅ\n\n‚óºÔ∏è Insert\n\nTo insert a new element it is necessary to find the first available space in the structure looking for an empty spot from top to bottom and left to right order.\n\nAfter that, it may be necessary to rearrange the structure, this process will compare the value inserted with the parent value based on the type of heap. The elements should be swap if not follow the heap property and continue to bubble until finding the right spot in the structure.\n\nIn this function, we might have to make a comparison at each level of the structure and then swap the elements until the root element. Every time a new value goes up it takes O(1) time. So, the worst-case time complexity is O(nlg n) because we insert the value at the end of the heap and traverse up.\n\ninsert(value){\n      this.list.push(value);\n      var childrenIndex = this.list.indexOf(value);\n\n      while(this.hasParentByIndex(childrenIndex)){\n          if(this.shouldSwap(childrenIndex, this.getParentByIndex(childrenIndex))){\n            this.swapElements(childrenIndex, this.getParentByIndex(childrenIndex));\n            childrenIndex = this.getParentByIndex(childrenIndex);\n          } else{\n             break;\n          }\n      }\n}\n\n\n\n  ‚ö°Ô∏è If you would like to learn others functions that I implemented you can access all the code just clicking here.\n\n\n‚óºÔ∏è Deletion\n\nIn the Heap, we remove the root element of the structure and then replace it with the last value added. As you may be thinking, the new root element might probably not be in the right position. To solve this problem it is necessary to call the heapify function, which is the most critical operation in this structure where it reorganizes the values until the heap property is satisfied.\n\nremoveFromTop(){\n     if(this.isEmpty())\n         throw new Error(&#39;The Heap is Empty&#39;);\n     if(this.getSize() == 1){\n         this.list.pop();\n     } else {\n         this.swapToRemove();\n         this.heapify();\n     }\n}\n\nswapToRemove(){\n    this.swapElements(this.list.length - 1, 0);\n    this.list[this.list.length - 1] = null;\n    this.list = this.list.filter(function (element) {\n        return element != null;\n    });\n}\n\nswapElements(childrenIndex, parentIndex) {\n    const tmp = this.list[parentIndex];\n    this.list[parentIndex] = this.list[childrenIndex];\n    this.list[childrenIndex] = tmp;\n}  \n\n\nUsing a top-down approach, this function will bubble it down comparing the new root element and the left and right child, then swap elements according to the type of heap and repeat the process until the new root element finds a valid spot and the heap property has been satisfied.\n\nLet‚Äôs see how we can put these words in a code.\n\n\nheapify(index=0){\n     let left = this.getLeftChildrenIndex(index),\n         right = this.getRightChildrenIndex(index),\n         largest = index;\n\n     if(!this.list[left]) return;\n\n     if(this.shouldSwap(left, largest) ){\n         largest = left;\n     }\n     if(this.shouldSwap(right, largest) ){\n         largest = right;\n     }\n     if(largest !== index){\n        [this.list[largest],this.list[index]] = [this.list[index],this.list[largest]];\n          this.heapify(largest);\n     }\n}\n\n\n\nWe can say that the main point of heapify function is to make sure that the structure follows the heap propriety by comparing the elements and the child elements.\n\nThe time complexity for swap element in each level is O(1) and the worst-case time is O(lg n) and it depends on how far an element can move down, which is related to the height of the heap. In the worst case, the element might go down all the way to the leaf level.\n\n\n  ‚ö°Ô∏è If you would like to learn others functions that I implemented you can access all the code just clicking here.\n\n\n‚óºÔ∏è Merge heaps\n\nTo merge two existing heap into a single one can be done by all values moved from the smallest heap to the largest using the insert function. However isn‚Äôt the best way because involves moving N items and rearranging at cost 0(log n), giving an overall time complexity of O(nlog n).\n\nThe best approach is just concatenate the values of two heaps and then use heapify algorithm, as we can see below:\n\nmergeHeaps(heap){\n     var array = []\n     for (var i = 0; i &amp;lt; this.size; i++) { \n         array[i] = this.list[i]; \n     } \n     for (var i = 0; i &amp;lt; heap.size; i++) { \n         array[this.size + i] = heap.list[i]; \n     } \n     var total = this.size + heap.size; \n     this.list = array\n  \n     for (var i = total / 2 - 1; i &amp;gt;= 0; i--) { \n         this.heapify(i)\n     } \n}\n\n\nWe are done üôå\n\n\n\n\nThat‚Äôs all, folks! I see you arround and wash your hands and use masks. üòÅüò∑\n\nCode: https://github.com/FernandoBLima/data-structures\n\n\n\nWe finished our discussion about Heap structure. üôå\n\nIf you found something I miss out or find this article helpful, feel free to let me know. üòÅ\n\n"
} ,
  
  {
    "title"    : "Trie - Data Structure &amp; Algorithm Part VI",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2020/05/27/data-structure-part-VI.html",
    "date"     : "May 27, 2020",
    "excerpt"  : "In this post our main goal is to understand the Trie Data Structure, learning the concepts, how it works, and how to implement it (a.k.a code!).\n\n\n\nIt is important to understand the tree structure before diving into the trie. So, if you need to, y...",
  "content"  : "In this post our main goal is to understand the Trie Data Structure, learning the concepts, how it works, and how to implement it (a.k.a code!).\n\n\n\nIt is important to understand the tree structure before diving into the trie. So, if you need to, you can read the last post about the tree and binary search tree.\n\nMoving on, let‚Äôs discuss the data structure journey! üòÅ\n\n\n  üí≠ ‚ÄúThose hours of practice, and failure, are a necessary part of the learning process.‚Äù- Gina Sipley\n\n\n\n\nOutline\nThe article is divided into the following parts:\n\n  Understanding the Trie structure;\n  The main operations\n\n\n‚óºÔ∏è Trie\n\n\n  Pre-requisite : Tree\n\n\nWe can say that the trie structure stores a set of strings that can be visualized like a tree where each node is a character. This structure is stored in a top to the bottom manner and the order that appears is based on the prefix of a string that all the descendants‚Äô nodes have in common.\n\nBut what do I mean about prefix? üßê\n\n\n\nLet‚Äôs consider using the word ‚ÄòBatman‚Äô for the set S of n strings to clarify our mind.\n\nS1 = { B,a,t,m,a,n }\n\n\nFirst all, the root of the structure is started with a node with value Œµ that represents the empty string. The next inserted node has the first value in the set S1 that is ‚ÄòB‚Äô. Then, the next node to be used is the value ‚Äòa‚Äô and so on.\n\nAs we can see, each node can have several child values ‚Äã‚Äã(or not). At most, the size of the alphabet that the children are connected to, in our case can have up to 26 children.\n\nSo, let‚Äôs see an example using the word that we are discussing.\n\n\n\nFigure 1: Inserted a new word\n\nGreat! Let‚Äôs use this structure and add a new set that has the word ‚ÄòBat‚Äô, using as the set S2 of n strings.\n\nS2 = { B,a,t}\n\n\nHere, the first letter ‚ÄòB‚Äô of the set S2 has already been inserted in the first node. Therefore, we do not have to create another node, and the same happens to the letters ‚Äòa‚Äô and ‚Äòt‚Äô. As a consequence, just need to mark the letter ‚Äòt‚Äô as the end of a word.\n\nSee the next figure below that shows a trie with the words ‚ÄúBatman‚Äù and ‚ÄúBat‚Äù.\n\n\n\nFigure 2: Inserting a word that already have the as prefix in the structure\n\nWhat‚Äôs happens if we add the word ‚ÄòBatgirl‚Äô?\n\nS3 = { B,a,t,g,i,r,l}\n\n\nAs we discussed earlier, the structure already have the letters ‚ÄòB‚Äô, ‚Äòa‚Äô, and ‚Äòt‚Äô. So, just needs to create the node for other words. See below:\n\n\n\nFigure 3: Inserting a word that already have a prefix \n\nWhat if we add a word that starts with a different letter instead of ‚ÄòB‚Äô? Don‚Äôt worry, just need to insert a new node with a value. In this example, we will add the word ‚ÄòJoker‚Äô, in this way, the letter ‚ÄòJ‚Äô will be added after the node that represents the empty string. Keep in mind, don‚Äôt forget to mark the last letter at the end of the word.\n\n\n\nThis happens with other words that can be added to our structure, such as Penguin, Ivy, Two-Face, and so on.\n\n\n\nFigure 4: Inserting a word that start with a different first letter\n\nAfter all, why should we use this structure? Why not use the tree structure? Well, the trie structure is faster compared to the tree and hash table because we do not need to calculate any hash functions or worry about dealing with collisions.\n\nAwesome! Now that we understand the behaviors and how we can add values, let‚Äôs build our structure. At first, we need to create our main class.\n\nTalk is cheap. Let‚Äôs see the code. üòÅ\n\nclass TrieNode {\n    constructor(isEnd, value ) {\n        this.children = {};\n        this.isEndOfWord = isEnd;\n        this.character = value;\n    }\n\n}\n\nclass Trie {\n    constructor() {\n        this.root = new TrieNode(true, &#39;*&#39;);\n        this.length = 0;\n    }\n\n    ...\n\n}\n\n\nEach TrieNode represents a letter in the structure and has the following parameters:\n\n  children: As we discussed above, there can be more than one child.\n  isEndOfWord: Represents if the letter is the end of the word.\n  character: Is the node value.\n\n\nDone! üòÅ\n\nBut not entirely! We need to create and add methods to our class. The implementation of insert, search and delete functions are a simpler way to implement these functions using Javascript, and all of these operations have the complexity of time O(L) where L is length of key.\n\nLet‚Äôs check out:\n\n\n  Insert\n\n\nAs mentioned earlier, this structure starts with a node that represents the empty string. We have to insert the first character of the set of strings, but if the value to be inserted has already been added, we just have to get down to the next level and continue to add the following values from the set.\n\nHowever, if at some point there is no node, we will have to create and continue the process until the whole set is inserted, and of course, mark the last value of the set as the end of the word node. The space complexity of this structure in the worst case is when the word to be inserted is higher than the maximum number of nodes in the structure.\n\n    insert(key){\n        var currentValue = this.root;\n        \n        for (let index = 0; index &amp;lt; key.length; index++) {\n            const element = key[index];\n            if (currentValue.children[element]) {\n                currentValue = currentValue.children[element];\n            } else {\n                this.length++;\n                const newNode = new TrieNode(false, element);\n                currentValue.children[element] = newNode;\n                currentValue = newNode;\n            }\n        }\n        currentValue.isEndOfWord = true;\n    }\n\n\n\n  Search\n\n\nSearching a string in this structure is a simple approach, we just have to iterate all characters of the set starting at the root and checking if the value matches and moving down to the next node. If the last letter used in the process is marked as the last node, then the set belongs to the searched word.\n\nHowever, we can say that the set S is not present in the trie when:\n\n  There is no transition for children nodes and there is still a letter in the set.\n  If all the letters have been consumed and the last node in the process does not correspond to the string.\n  Or all characters exist in the structure, but the last letter is not marked as the end of the word node.\n\n\n    searchWord(key){\n        var currentValue = this.root;\n        for (let index = 0; index &amp;lt; key.length; index++) {\n            const element = key[index];\n            if (currentValue.children[element]) {\n                currentValue = currentValue.children[element];\n            } else{\n                return null;\n            }\n        }\n        return currentValue;\n    }\n\n\n\n  Suggestion Word\n\n\nThe main goal of this function is to show all words that have a prefix in common. At the beginning, is searched if the set of string already has been inserted in the structure and returns a list that contains all words that contain the word as a prefix.\n\n\n    suggestionWord(key) {\n        var word = this.searchWord(key);\n        if(word){\n            var suggestions = [];\n            if(word.isEndOfWord){\n                suggestions.push(key);\n            }\n            return this._suggestionWord(word, key, suggestions);\n        }\n        return [];\n    }\n\n\n    _suggestionWord(node, lastWord, suggestions){\n\n        var letters = Object.keys(node.children); \n        for (let index = 0; index &amp;lt; letters.length; index++) {\n            const element = letters[index];\n            if(node.children[element].isEndOfWord){\n                suggestions.push(lastWord + node.children[element].character);\n                this._suggestionWord(node.children[element], lastWord + node.children[element].character, suggestions);\n            }else{\n                var rest = lastWord + node.children[element].character;\n                this._suggestionWord(node.children[element], rest, suggestions);\n            }\n        }\n\n        return suggestions;\n    }\n\n\n\n\n  Remove\n\n\nIn this function, the word is removed from the structure if contains the prefix and does not have any other words that use as a prefix.\n\n  remove(key) {\n        if(this.search(key)){\n            return this._removeNode(this.root ,key, key, 0);\n        }else{\n            return false;\n        }\n    }\n\n    _removeNode(node, keySlice ,key, index) {\n        var letter = key[index];\n        var current = node.children[letter];\n        if(current){\n            keySlice = key.slice(index + 1, key.length);\n            var shouldRemove = this._removeNode(current, keySlice, key, index + 1 );\n            if(shouldRemove &amp;amp;&amp;amp; !this.hasChild(node.children[letter].children)){\n                this.length--;\n                delete node.children[letter];\n                key = keySlice;\n                return true;\n            }else{\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n\n\nThat‚Äôs all folks! I hope you have fun learning. üòÅ\n\n\n\nCode: https://github.com/FernandoBLima/data-structures\n\n\n\nSo we finished our discussion about Trie structure. üôå\n\nI hope you have a clear idea how to work. If you found this article helpful or if you find something I miss out or that you like it, feel free to let me know. üòÅ\n"
} ,
  
  {
    "title"    : "Tree and Binary Search Tree - Data Structure &amp; Algorithm Part V",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2020/04/21/data-structure-part-V.html",
    "date"     : "April 21, 2020",
    "excerpt"  : "Finally, this series will talk about the tree structure and I am very excited because it is one of the most important structures and there is a lot to cover. üòÅ\n\n\n\nOf course, it will be impossible to cover everything in just one article. In this wa...",
  "content"  : "Finally, this series will talk about the tree structure and I am very excited because it is one of the most important structures and there is a lot to cover. üòÅ\n\n\n\nOf course, it will be impossible to cover everything in just one article. In this way, to keep things simple, we will have other articles to discuss this structure. However, this does not mean that what we are going to learn is not important! We will focus on the tree and binary search tree that are powerful concepts and that will help us to develop our knowledge to future articles! üë©‚Äçüíªüë®‚Äçüíª\n\nBut wait for a second! Before winter comes, if you are unfamiliar or need to remember some concepts about data structures, I highly recommend reading the most recents posts in this series.\n\nNow that you are ready for the winter, go ahead and may the Seven gods protect you in the game of thrones.\n\nBecause winter is coming!\n\n\n\n\n  üí≠ ‚ÄúPeople have an enormous tendency to resist change. They love to say, ‚ÄòWe‚Äôve always done it this way‚Äô. I try to fight that.‚Äù - Grace Hopper\n\n\nOutline\n\n  Basic concepts\n  Terminology\n  Types of Trees: Tree, Binary Tree and Binary Search Tree\n  The main operations and properties.\n\n\n‚óºÔ∏è Tree üå≥\n\nWe can describe the simplest definition of tree structure by saying that it stores and manipulates elements hierarchically, and this is one of the biggest differences with other structures.\n\nSo, let‚Äôs look at how this structure works using the following example:\n\n\n\nFigure 1: representation.\n\nOne of the first steps to understand the structure is to understand the main concepts. As we can see in the image above, each character in Stark House represents a node element in the tree structure. The node on the top is the Rickard Stark element and is called the root of the tree because it starts the structure and does not have a parent node.\n\nAll elements that are under an element are represented as children, for instance, Eddard, Benjen, and Lyanna elements are related as children of the Rickard node and the link between a node to another, like Rickard and Eddard, is called an edge.\n\nAnother thing to discuss in this picture is related to Robb, Sansa, Arya, Bran, Rickon, and Jon Snow (You know nothing!) elements, they represent leaves because they do not have children.\n\nOkay, the next step is to define the main class which is NodeTree, as you can see in the following code:\n\nclass NodeTree {\n    constructor(key) {\n        this.key = key;\n        this.descendents = [];\n    }\n}\n\n\nNow we are going to create a simple example where we can add new values to the tree and then remove it. In this code, we create the Tree constructor that has the link to the root element and the number of nodes in the structure.\n\nBesides that, there is a function to insert a new value that we can specify where the value will be added. For instance, if the structure already has the root element, a new value will be added as a descendent node. However, we can specify the parent node of the new element. Another function is to remove a value from the structure that does a search on all child elements.\n\nTake a look at the code below:\n\nclass Tree {\n    constructor() {\n        this.root = null;\n        this.length = 0;\n    }\n\n    add(value, root = null) {\n        if(!this.root){\n            this.root = new NodeTree(value);\n        } else {\n            if(!root){\n                this.root.descendents.push(new NodeTree(value));\n            } else {\n                var currentRoot = this.getValue(root);\n                currentRoot.descendents.push(new NodeTree(value));\n            }\n        }\n    }\n\n    remove(value) {\n        var queue = [this.root];\n        while(queue.length) {\n            var node = queue.shift();\n            for(var i = 0; i &amp;lt; node.descendents.length; i++) {\n                if(node.descendents[i].key === value) {\n                    node.descendents.splice(i, 1);\n                } else {\n                    queue.push(node.descendents[i]);\n                }\n            }\n        }\n    }\n\n    ...\n\n}\n\n\n‚óºÔ∏è Binnary Tree\n\nAs the name suggests, a binary tree it is a tree whose elements have at most 2 children, called left and right. Simple right?  We should keep in mind that every node is a representation of a subtree itself. That said, a node can have two subtrees.\n\n‚óºÔ∏è Binnary Search Tree (BST)\n\nBinary Search Tree is a rooted binary tree and each node store a key and can have two children like the binary tree. But what is the difference between them? An important thing to remember is that the root element must satisfy the property to be greater than all keys stored in the left sub-tree, and not greater than all keys in the right sub-tree which provides the efficient way of data sorting, searching and retriving.\n\nIn general, the worst case of time complexity is O (h), where h is the height of the BST, because it depends on how many elements and the order we must go through.\n\nTo implement a binary search tree we have to update the NodeTree class, in order to support the binary search tree property.\n\nclass NodeTree {\n    constructor(key) {\n        this.key = key;\n        this.left = null;\n        this.right = null;\n    }\n}\n\n\nLet‚Äôs take a look at the following image:\n\n\n\nFigure 2: Binary Tree representation.\n\nOperations\n\nNow we will learn some operation to build our structure.\n\n- Insert\n\nAs we discussed above, the root element must be greater than all left subtree elements and smaller than right subtree and this must occurs to all elements in the structure. In this way, when a new element is inserted must be verified the value. When a value is less than the node‚Äôs key it must be added to the left sub-tree, otherwise it must be added to the right subtree. An important thing to get note is that duplicate nodes are not allowed in the tree.\n\nWe implement a binary search tree using the class NodeTree. Here is how a binary search tree insertion might be:\n\n    insert(value){\n        if(!this.root){\n            this.root = new NodeTree(value);\n            this.length++;\n        }else{\n            this._insertNode(this.root, value);\n            this.length++;\n        }\n    }\n    \n    _insertNode(currentNode, value){\n        if(currentNode.key){\n            if(value &amp;lt; currentNode.key){\n                if(!currentNode.left){\n                    currentNode.left = new NodeTree(value);\n                }else{\n                    this._insertNode(currentNode.left, value);\n                }\n            } else {\n                if(!currentNode.right){\n                    currentNode.right = new NodeTree(value);\n                }else{\n                    this._insertNode(currentNode.right, value);\n                }\n            }\n            return;\n        }\n    }\n\n\n- Search\n\nWhen we want to search for an element, we have to follow the same logic as the previous function. Remember that an element is searched from the root node if the value is less than the root node, then we must traverse to the left subtree, otherwise, the search will be directed to the right subtree. Once you understand how value is inserted, it becomes easier to create other functions, right?\n\nOne of the main differences between this structure to the others is the fact that we can search for an element more quickly than the Linked List, but it is slower compared to arrays. This behavior can occur in the same way to insert and delete functions.\n\n    search(value){\n        if(!this.root){\n            return null;\n        }else{\n            return this._search(this.root, value);\n        }\n    }\n\n    _search(node, value){\n        if(node){\n            if(node.key != value){\n                if(value &amp;lt; node.key){\n                    return this._search(node.left, value);\n                }else{\n                    return this._search(node.right, value);\n                }\n            }else{\n                return node.key;\n            }\n        }else{\n            return null;\n        }\n    }\n\n\n- Delete\n\nTo remove an element in the binary search tree, three are some of the possibilities that must be followed, which are:\n\n\n  If the value to be deleted is a leaf, then we just need to remove it from the tree.\n  When a node has only one child, in this case, we need to remove the value and copy the child to the node.\n  If a node element to be deleted has two children, it is necessary to find the inorder successor of the node.\n\n\nBelow is an example:\n\n    delete(value){\n        if(!this.findNode(value)){\n            return false;\n        }\n        this._delete(this.root, value);\n        return true;\n    }\n\n    _delete(node, value){\n        if(node == null) return node;\n\n        var parent = this.findParent(value);\n        if(!parent &amp;amp;&amp;amp; node.left == null &amp;amp;&amp;amp; node.right == null){\n            return this.root.key = null;\n        }\n\n        if(value &amp;lt; node.key){\n            node.left = this._delete(node.left, value);\n        }else if(value &amp;gt; node.key){\n            node.right = this._delete(node.right, value);\n        }else{\n            if(node.left == null){\n                return node.right;\n            }else if(node.right == null){\n                return node.left;\n            }\n            node.key = this._minValue(node.right); \n            node.right = this._delete(node.right, node.key);\n        }\n        return node;\n    }\n\n\n\n  ‚ö°Ô∏è The binary Search Tree is a extend topic to discuss and learn, if you would like to learn others functions that I implemented such as listLeafNodes, findParent, findMaximum, findMinimum and others, you can access all the code just clicking here.\n\n\nTypes of binary trees\n\nOkay, now that we already understand the main operations in a binary search tree, we can move on and discuss some other properties. We can classify the binary search tree into the following types of Binary Trees:\n\n\n  Full Binary Tree\n\n\nIt is considered a full binary tree if all nodes, except the leaves, have two children. The following image shows an example of a full binary tree.\n\n\n\nFigure 3: A full binary tree example \n\n   isFull(){\n        if(this.root == null || this.root.left == null &amp;amp;&amp;amp; this.root.right == null ) \n            return true; \n        return this._isFull(this.root);\n    }\n\n    _isFull(root){\n        if(root == null || root.left == null &amp;amp;&amp;amp; root.right == null ) \n            return true; \n\n        if ((root.left == null &amp;amp;&amp;amp; root.right != null) ||\n            (root.left != null &amp;amp;&amp;amp; root.right == null))\n                return false; \n\n        if((root.left != null) &amp;amp;&amp;amp; (root.right != null)) \n            return (this._isFull(root.left) &amp;amp;&amp;amp; this._isFull(root.right));    \n    }\n\n\n\n  Complete Binary Tree\n\n\nHere, we can say that a Binary Tree is complete when all levels are full, the only exception being the last level.\n\n\n\nFigure 4: A complete binary tree example \n\n    isComplete(){\n        if (this.root == null)         \n            return true; \n        let numberNodes = this.countNode();\n        return this._isComplete(this.root, 0, numberNodes);\n    }\n\n    _isComplete(root, index, numberNodes) {\n        if (root == null)         \n            return true; \n\n        if (index &amp;gt;= numberNodes) \n            return false; \n\n        return (this._isComplete(root.left, 2 * index + 1, numberNodes) \n            &amp;amp;&amp;amp; this._isComplete(root.right, 2 * index + 2, numberNodes));\n    }\n\n\n\n  Perfect Binary Tree\n\n\nWhen a binary tree is complete and full at the same time, it is considered a Perfect Binary Tree, which means that all levels have elements and all leaf nodes are at the same level.\n\n\n\nFigure 5: A perfect binary tree example \n\n   isPerfect() {  \n        if (this.root == null)  \n            return true;  \n        let leftMostLeaf = this.leftMostLeaf(this.root);  \n        return this._isPerfect(this.root, leftMostLeaf, 0);  \n    }  \n\n    leftMostLeaf(node) {  \n        let depth = 0;  \n        while (node != null)  \n        {  \n            depth++;  \n            node = node.left;  \n        }  \n        return depth;  \n    }  \n\n    _isPerfect(root, d, level) {  \n        if (root == null)  \n            return true;  \n    \n        if (root.left == null &amp;amp;&amp;amp; root.right == null)  \n            return (d == level+1);  \n    \n        if (root.left == null || root.right == null)  \n            return false;  \n    \n        return this._isPerfect(root.left, d, level+1) &amp;amp;&amp;amp; this._isPerfect(root.right, d, level+1);  \n    }  \n\n\nBinary Tree Traversal\n\nWe can visit all nodes in a tree differently, generally, it starts at the root node to search or locate a particular tree, or to print all the values it contains. With this concept in mind, let‚Äôs take a look at in the most commons ways to traverse a binary tree.\n\n\n\nFigure 5: A binary search tree example \n\n\n  Pre-order\n\n\nIn this function, the order that we must follow is to visit the root node first, and then go through all elements on the left subtree and the right subtree of the root.\n\nRoot -&amp;gt; Left Tree -&amp;gt; Right Tree\n\n\nAs I said before, every node is a representation of a subtree itself. With that in mind, when a leaf node is located, which has no left and right subtree, we say that it has been completely traversed. As a consequence, the right node of the subtree will be visited. This process occurs until all elements are visited.\n\nPreOrder traversal : [ 100, 50, 25, 75, 150, 125, 175 ].\n\n    preOrder(){ \n        if (this.root == null) \n            return null; \n        var listValues = [];\n        return this._preOrder(this.root, listValues); \n    } \n\n    _preOrder(node, listValues){\n        if(node.key != null) \n            listValues.push(node.key);\n        if(node.left != null) \n            this._preOrder(node.left, listValues);\n        if(node.right != null) \n            this._preOrder(node.right, listValues);\n        return listValues;\n    }\n\n\n\n  In-order\n\n\nIn this traversal method, its traverse to the left subtree first by recursively. At first, it visited all elements of the left subtree of the root, then the node root and all elements of the right subtree.\n\nLeft Tree -&amp;gt; Root -&amp;gt; Right Tree\n\n\nInorder traversal : [ 25, 50, 75, 100, 125, 150, 175 ].\n\n    inOrder(){ \n        if (this.root == null) \n            return null; \n        var listValues = [];\n        return this._inOrder(this.root, listValues); \n    } \n\n    _inOrder(node, listValues){\n        if(node.left != null) \n            this._inOrder(node.left, listValues);\n        if(node.key != null) \n            listValues.push(node.key);\n        if(node.right != null) \n            this._inOrder(node.right, listValues);\n        return listValues;\n    }\n\n\n\n  Post-order\n\n\nIn this method, we traverse the left subtree, the right subtree, and the root node.\n\nLeft Tree -&amp;gt; Right Tree -&amp;gt; Root\n\n\nPost-order traversal: [ 25, 75, 50, 125, 175, 150, 100 ].\n\n    posOrder(){ \n        if (this.root == null) \n            return null; \n        var listValues = [];\n        return this._posOrder(this.root, listValues); \n    } \n\n    _posOrder(node, listValues){\n        if(node.left != null) this._posOrder(node.left, listValues);\n        if(node.right != null) this._posOrder(node.right, listValues);\n        if(node.key != null) listValues.push(node.key);\n        return listValues;\n    }\n\n\n\n  Level order\n\n\nAnother important way to traverse in a tree is the level-order that visits every node on a level before going to a lower level.\n\nLevel order: [ 100, 50, 150, 25, 75, 125, 175 ].\n\n   levelOrderQueue() {\n        if (this.root == null)\n            return null;\n        \n        var listOrderQueue = [];\n        listOrderQueue.push(this.root);\n        var listValues = []\n\n        while (listOrderQueue.length &amp;gt; 0) {\n            var n = listOrderQueue.shift();\n\n            if (n.left != null)\n                listOrderQueue.push(n.left);\n\n            if (n.right != null)\n                listOrderQueue.push(n.right);\n            \n            listValues.push(n.key)\n        }\n        return listValues;\n    }\n\n\n\n\nThat‚Äôs all, folks! I hope you are taking care of Yourself üòÅ\n\n\n\nCode: https://github.com/FernandoBLima/data-structures\n\n\n\nSo we finished our discussion about Tree and Binary Search Tree structure. üôå\n\nI hope you have a clear idea how to work. If you found this article helpful or if you find something I miss out or that you like it, feel free to let me know. üòÅ\n\n"
} ,
  
  {
    "title"    : "Disjoint Set - Data Structure Part IV",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2020/03/04/data-structure-part-IV.html",
    "date"     : "March 4, 2020",
    "excerpt"  : "This is the fourth part of the Data Structure series. If you haven‚Äôt read this series yet, I recommend you check it out first! In this series, we‚Äôve already learned that there are different ways to organize data using variables, arrays, hashes and...",
  "content"  : "This is the fourth part of the Data Structure series. If you haven‚Äôt read this series yet, I recommend you check it out first! In this series, we‚Äôve already learned that there are different ways to organize data using variables, arrays, hashes and objects in data structures.\n\n\n\nWe discussed linked list, hash and set structure, however, this is just the tip of the iceberg! There is much more to come and learn. Relax, take it easy, because we will learn step by step. So, you don‚Äôt have to worry, even if it sounds hard to hear.\n\n\n  üí≠ ‚ÄúThose hours of practice, and failure, are a necessary part of the learning process.‚Äù- Gina Sipley\n\n\nOutline\nThe article is divided into the following parts:\n\n\n  Understanding what Disjoint Set is.\n  How the union and merge function works?\n  How to optimize the union function?\n  Code implementation and complexity analysis.\n\n\n‚óºÔ∏è Disjoint Set\n\nWe will continue what we already had learned in the last post about sets. \nA disjoint-set data structure is also called a union-find or merge‚Äìfind set. It‚Äôs like every data structure has more than one name, right? üòÇ So, I will refer only to the Disjoint Set, because it looks more sophisticated and scientific to me. üë®‚Äçüíªüë©‚Äçüíª This structure has several applications but the most known is in the Kruskal‚Äôs algorithm.\n\nBut what is a Disjoint Set? üßê\n\n\n\nA good way to understand this structure is imagining that we have more than one element that belong to a set and is partitioned into further subsets. That is to say, in this structure, the elements can keep the track of elements of the set, as you can see on the following image, where each element can have a child and parent element.\n\n\n\nFigure 1: Disjoint Set representation.\n\nWe can use the same approach that we used in the last post where we learned that the linked list is not a good option because it does not perform well. That‚Äôs a result because the efficiency of an algorithm most of the time is related to how the data is used in an efficient way in a data structure. So, how we can build the Disjoint Set?\n\nBefore diving into this structure, we need first to discuss our main class. That said, when a Disjoint Set is created it is necessary to initialize our structure using the init function that creates all the elements, this function has O(n) of time complexity. But how exactly does this function work?\n\nIn this code, each element is a reference to the DisjointSetNode class and it is put as root at the beginning, which means that the parent property is mapped to itself. Furthermore, when an element has no child elements, it is called the root of a structure and is set to -1 for the parent property, as a consequence, all elements belong to a different set, pretty simple, right?\n\nOur main class would look something like this:\n\nclass DisjointSetNode {\n    constructor(value) {\n        this.value = value,\n        this.children = {};\n        this.rank = 1;\n        this.parent = -1;\n    }\n}\n\nclass DisjointSet {\n    constructor() {\n        this.list = {};\n        this.size = 0;\n    }\n\n    init(size){\n        this.size = size;\n        for (var i = 0; i &amp;lt; this.size; i++) {\n            var disjointSetNode = new DisjointSetNode(i);\n            this.list[i] = disjointSetNode;\n        }\n    }\n\n    ...\n\n}\n\n\nOkay, let‚Äôs move on and take more steps forward to continue the discussion now that we understand how to initialize the structure. We can summarize and define the Disjoint Set with just two primary operations: find and union.\n\n\n  Find\n\n\nAs the name suggests, this operation follows the parent element until a root element is reached, in other words, finding the value whose parent is itself.\n\n    findRoot(x) {\n        if (this.list[x] &amp;amp;&amp;amp; this.list[x].parent !== -1) {\n            return this.findRoot(this.list[x].parent);\n        }else{\n            return this.list[x];\n        }\n    }\n\n\n\n  Union\n\n\nThe basic idea for this function is to merge two distinct roots and making one of the roots as a parent of the root of the other.\n\nI provided a simple code implementation for this function, note that the number of roots never increases and this occurs when the elements are merged, instead, the number of roots decreases. As we can see in our example below:\n\n    union(x, y){\n        var xRoot = this.findRoot(x);\n        var yRoot = this.findRoot(y);\n\n        yRoot.parent = -1;\n        yRoot.children[xRoot.value] = xRoot;\n        xRoot.parent = yRoot.value;\n    }\n\n\nOk, let‚Äôs see the example below that merges some values ‚Äã‚Äãto help us make the understanding of this structure clearer, let‚Äôs use the following subset S = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9 } and merge some elements.\n\ndisjoinSet.init(10);\n\ndisjoinSet.union(2,1)\ndisjoinSet.union(2,3)\ndisjoinSet.union(3,4)\ndisjoinSet.union(5,4)\ndisjoinSet.union(4,6)\n\n\nThe result will look something like this:\n\n\n\nFigure 2: Example of union operation.\n\nAfter union operations, you can see that there are now 5 subsets. First there is the element {0}, then {6 4 3 1 2 5}, {7}, {8} and {9}. Another important function that we can use is isConnected, used to check whether the elements are in the same set or not. For instance, we can find out if the values ‚Äã‚Äã2 and 6 below in the same group if they have the same root, therefore, this will give us a true result. See the code below:\n\nisConnected(value1, value2){\n     if(this.findRoot(value1).value == this.findRoot(value2).value) \n         return true;\n     return false;\n}\n\n\n\n  ‚ö°Ô∏è If you would like to know others functions that I implemented such as getSetSize, extractSets, getChildrenByItem, and others, you can access all the code just clicking here.\n\n\nCan you see the problem that can occur if we continue to link one element as a child of another using the union function? To check if values 2 and 6 belong to the same group, you will need four hops in the example above. It is a consequence of the union function that makes the structure grow by ùëÇ(ùëÅ). If we deal with a large data set, this approach may not be efficient, with that in mind, one way to optimize this problem and reduce the execution time is by using one of the following ways:\n\n\n  Union By Size\n\n\nIn this function, we connect the sets by the size where the root of the smaller structure is linked to the root of the larger structure. Initially, each element is a subset, in other words, it has size 1.\n\nThe code example:\n\n    unionBySize(x, y){\n        var xRoot = this.list[x];\n        var yRoot = this.list[y];\n        \n        if(this.getSetSize(xRoot.value) &amp;gt; this.getSetSize(yRoot.value)){\n            yRoot.parent = xRoot.value;\n            xRoot.children[yRoot.value] = yRoot;\n        } else {\n            xRoot.parent = yRoot.value;\n            yRoot.children[xRoot.value] = xRoot;\n        }\n    }\n\n\nThe getSetSize function is used to return the size of the structure, making the element that belongs to the smallest structure size points to the set that has the largest size. The following code is an example of this scenario.\n\ndisjoinSet.unionBySize(2,1);\ndisjoinSet.unionBySize(2,3);\n\ndisjoinSet.unionBySize(0,4);\ndisjoinSet.unionBySize(5,4);\ndisjoinSet.unionBySize(4,6);\n\ndisjoinSet.unionBySize(3,6);\n\n\n\n\nFigure 3: Example of Union By Size operation.\n\n\n  Union By Rank\n\n\nWe can use a different way to optimize the structure using the rank, which means that is used the height of the set instead of the size to link the root of a smaller rank to the root with a larger rank. Another key thing to remember is that each element initially has 0 of rank. However, when the roots have the same rank, only the rank of the new root increases by 1 otherwise, no change occurs. Let‚Äôs create an example:\n\ndisjoinSet.unionBySize(4,5);\ndisjoinSet.unionBySize(6,7);\ndisjoinSet.unionBySize(4,6);\ndisjoinSet.unionBySize(3,4);\n\n\nTake a look at the code below:\n\n   unionByRank(x, y){\n        var xRoot = this.findRoot(x);\n        var yRoot = this.findRoot(y);\n\n        if(xRoot.value == yRoot.value)\n            return;\n\n        if(xRoot.rank &amp;lt; yRoot.rank){\n            xRoot.parent = yRoot.value;\n            yRoot.children[xRoot.value] = xRoot;\n        } else if (xRoot.rank &amp;gt; yRoot.rank) {\n            yRoot.parent = xRoot.value;\n            xRoot.children[yRoot.value] = yRoot;\n        } else {\n            xRoot.parent = yRoot.value;\n            yRoot.children[xRoot.value] = xRoot;\n            yRoot.rank = xRoot.rank + 1;\n        }\n    }\n\nUsing the union by rank function the worst-case running time per operation is ùëÇ(logùëõ).\n\n\n  Path Compression\n\n\nWe can use Path Compression to optimize the Union by size and that‚Äôs what makes this structure remarkable. The idea behind this function is to flatten the structure when the find() function is used. After finding the root of all the elements along the way, the elements point each one directly to the root. As a result, efficiency is increased compared to the basic union operation.\n\nBut before showing how this operation works, let‚Äôs take a few steps back and compare it to the worst case scenario. Let‚Äôs say there are 4 elements {0,1,2,3} and then we merge to understand how the find and join operation are important in this function.  As we can see:\n\ndisjoinSet.union(0,1);\ndisjoinSet.union(1,2);\ndisjoinSet.union(3,0);\n\n\nAs we discussed earlier, in this situation the height of our structure can grow quickly, after each step you can observe that the height is growing which brings us a poor performance. If we perform theses operations above, then the result it will be:\n\n\n\nFigure 4: Example of the worst case scenario using the union operation.\n\nWe can avoid this, merging the same elements that we used on last example but comparing the union function using the path compression technique, where each element along the path is compressed and point to the root in the structure.\n\ndisjoinSet.unionByPathCompression(0,1);\ndisjoinSet.unionByPathCompression(1,2);\ndisjoinSet.unionByPathCompression(3,0);\n\n\n\n\nFigure 5: Example of union operation using the path compression technique.\n\nWhat if we use this path compression and union by rank? See the image below:\n\ndisjoinSet.unionByRankByPathCompression(0,1);\ndisjoinSet.unionByRankByPathCompression(1,2);\ndisjoinSet.unionByRankByPathCompression(3,0);\n\n\n\n\nFigure 6: Example of union by rank operation using the path compression technique.\n\nGreat! We improved the performance and the time complexity of each operation becoming smaller than O(Logn), reducing the complexity of union. Let‚Äôs see how is the code:\n\n    unionByRankByPathCompression(x, y){\n        var xRoot = this.findByPathCompression(x);\n        var yRoot = this.findByPathCompression(y);\n\n        if(xRoot == yRoot)\n            return;\n\n        if(xRoot.rank &amp;lt; yRoot.rank){\n            xRoot.parent = yRoot.value;\n            yRoot.children[xRoot.value] = xRoot;\n        } else if (xRoot.rank &amp;gt; yRoot.rank) {\n            yRoot.parent = xRoot.value;\n            xRoot.children[yRoot.value] = yRoot;\n        } else {\n            xRoot.parent =  yRoot.value;\n            yRoot.children[xRoot.value] = xRoot;\n            yRoot.rank = xRoot.rank + 1;\n        }\n    }\n\n\n\nHowever, the bad news is that we can not use this approach using the union by rank because as we can see, this operation changes the heights of the structure.\n\n\n\nThat‚Äôs all folks! I hope you have fun learning the disjoint set structure üòÅ\n\nCode: https://github.com/FernandoBLima/data-structures\n\n\n  \n    \n      &amp;lt; previous\n      next ( coming soon) &amp;gt;\n    \n  \n\n\n\n\nSo we finished our discussion about Disjoint Set structure. üôå\n\nI hope you have a clear idea how to work. If you found this article helpful or if you find something I miss out or that you like it, feel free to let me know. üòÅ\n"
} ,
  
  {
    "title"    : "Set and MultiSet -‚Ää Data Structure &amp; Algorithms Part III",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2019/12/30/data-structure-part-III.html",
    "date"     : "December 30, 2019",
    "excerpt"  : "Welcome to the third part of the series, in this post I‚Äôll tell you about the set and multiSet structure and continue our journey on data structure and algorithm. üë©‚Äçüíªüë®‚Äçüíª However, I recommend reading the hashtable post if you are not familiar with ...",
  "content"  : "Welcome to the third part of the series, in this post I‚Äôll tell you about the set and multiSet structure and continue our journey on data structure and algorithm. üë©‚Äçüíªüë®‚Äçüíª However, I recommend reading the hashtable post if you are not familiar with data structures.\n\n\nBecause, unlike the last post when we landed on a strange terrain, here we will be a place where we should already have seen it before. The focus of this post is to learn what a set is with examples of how it works, code implementation using javascript and, of course, answer any questions about it. This data structure is not difficult to learn at first, but it can be a bit complicated.\n\nLet‚Äôs continuing our journey! üåè üöÄ\n\n\n  üí≠ ‚ÄúThose hours of practice, and failure, are a necessary part of the learning process.‚Äù- Gina Sipley\n\n\nOutline\n\nThe article is divided into the following parts:\n\n\n  Understanding what is Set and MultiSet.\n  Code implementation and complexity analysis.\n\n\n‚óºÔ∏è Set\n\nWhat is it\n\nAs you can imagine you already have some basic understanding about what is the sets structure. Basically is a collection of unique elements that can be objects, numbers, strings, Pok√©mon‚Äôs ‚Ä¶ In other words, anything! üòÅ\n\nWe can also find in many language that support the set such as Java, C, Python, .NET Framework and so on. For instance, the ECMAScript 6 or ES2015 introduced the Set data structure to the JavaScript language. We can initialized by calling:\n\nconst s = new Set()\n\n\nDespite the fact that we can use this implementation, we will avoid and build our own because the goal here is to learn how this structure works behind the scenes.\n\nWith that in mind, what we need to create our structure is use an array and add some element. We can also use the list structure, but it is an inefficient and simple implementation where operations such as inserting or deleting do not perform well. Having been said that, there are better approaches to implemented using more efficient data structures such as trees, tries, or hash tables, however, in this post we will use the array and the hash table that we already have seen in this series.\n\n\n\nGreat! We already have a basic understanding of how we can build the structure of the set, now let‚Äôs discuss some properties. Every value you insert have to appear only once because this structure does not allow repeated values, see the example below:\n\nA = [1,2,3,4,5,6] // Allowed\nB = [1,2,1,2,1,2] // Not Allowed\n\n\nMoreover, other important factor about this structure is related by the fact that we do not need to order the elements, for instance:\n\nC = [1, 2, 3] \nD = [3, 2, 1] \n// The Set C is the same as set D.\n\n\nWe can say that this structure is an implementation of the mathematical concept of a finite set using the operations of the algebra of sets. Okay, let‚Äôs put everything that we had learned into our code. But first things first, we will be creating the skeleton off our set class and, as you can notice we have two functions created.\n\nclass SetStructure {\n    constructor() {\n        this.listValues = [];\n        this.capacity = 0;\n    }\n\n    insert(value){\n        if(this.listValues.indexOf(value)) {\n            this.listValues.push(value);\n            this.capacity++;\n        }\n    }\n\n    remove(value){\n        var index = this.listValues.indexOf(value);\n        if(index &amp;gt;= 0) {\n            if(this.capacity &amp;gt; 1){\n                this.listValues.splice(index, 1);\n            }\n            this.capacity--;\n        }\n    }\n}\n\n\nBut, wait a second! ‚úã Before insert some values we must make sure if the value that we intend insert is not in our array. In the insert() function use the indexOf() propriety to verify if has any occurrence of a specified value in our structure. This method returns the position of element, however, if the array does not contain the data, the value -1 will be returned. We can use a similar logic in remove() function.\n\nAs mentioned earlier, this structure is based on the mathematical concepts of sets; therefore, we can use its properties in our code to define some operations using set algebra, such as union and intersection. Let‚Äôs have a brief discussion of the core set theoretical operations, so take a look below:\n\n\n  Union\n\n\nAs the name suggest this operation will join two sets resulting in a new set structure that combine all members of either A or B set. We can use the math definition to define this operation:\n\nA U B = {x : x ‚àà A or x ‚àà B} \n\nLet‚Äôs put in an example:\n{1, 2} ‚à™ {1, 2} = {1, 2}.\n{1, 2, 3} ‚à™ {3, 4, 5} = {1, 2, 3, 4, 5}\n\n\nTo give an illustration of how the union operation is, take a look at the following image:\n\n\n\n Figure 1: The union of A and B \n\nNow that we already have a clearly understanding, lets see how it works in our code.\n\nunion(set) {\n     var newSet = new SetStructure();\n     set.listValues.forEach(function(value) {\n         newSet.insert(value);\n     });\n     this.listValues.forEach(function(value) {\n         newSet.insert(value);\n     });\n     return newSet;\n};\n\n\n\n  Intersect\n\n\nIn this operation a new set is created using all elements that the both sets have in common, that can be denoted by A ‚à© B. In case of A ‚à© B = ‚àÖ, then A and B are considered disjoint. The math concept about the intersect is defined as the following:\n\nA ‚à© B = {x : x ‚àà A and x ‚àà B}\n\n\n\n Figure 2: The intersection of A and B \n\nAnd we can write the function that receives a set as parameter like this:\n\n    intersect(set) {\n        var newSet = new SetStructure();\n        this.listValues.forEach(function(value) {\n            if(set.contains(value)) {\n                newSet.insert(value);\n            }\n        });\n        return newSet;\n    };\n\n\n\n  Difference\n\n\nThe difference operation, or complement if you prefer, is the difference between the set A and B. But what does it mean? üßê In other words, is the result of the values that contains in only one set and can be denoted by the following definition:\n\nA \\ B or A ‚àí B where {x : x ‚àà B, and x ‚àâ A} \n\n\n\n Figure 3: The difference of A and B \n\nSimilar to union and intersect functions, we can iterate the list to get the difference between the sets:\n\n    difference(set) {\n        var newSet = new SetStructure();\n        this.listValues.forEach(function(value) {\n            if(!set.contains(value)) {\n                newSet.insert(value);\n            }\n        });\n        return newSet;\n    }\n\n\n\n  Symmetric Difference\n\n\nAnother operation that we can create is the symmetric difference, also know as disjunctive union, which is the set where the elements not below in their intersection.\n\n\n\n Figure 4: The symmetric difference of A and B \n\n    symmetricDifference(set) {\n        var newSet = new SetStructure();\n        this.listValues.forEach(function(value) {\n            if(!set.contains(value)) {\n                newSet.insert(value);\n            }\n        });\n        var setDifference = this;\n        set.listValues.forEach(function(value) {\n            if(!setDifference.contains(value)) {\n                newSet.insert(value);\n            }\n        });\n        return newSet;\n    }\n\n\n\n  ‚ö°Ô∏è If you would like to know others functions that I implemented such as removeAll, getAllSubsets, contains, and others, you can access all the code just clicking here.\n\n\n\n  Subset\n\n\nThe next operation define if every value of set A belongs to the set B and vice-versa. If they contain each other can denoted as A ‚äÜ B, which can be write as A is contained in B, is equivalent to A = B.\n\n    isSubset(set) {\n        return set.listValues.every(value =&amp;gt; this.listValues.includes(value)); \n    }\n\n\n\n  Proper Subset\n\n\nIt is quite similar to subset operation, but two sets can be considered as proper subset if one set is not equal to another but has at least one element.\n\n    isProperSubset(set){\n        return set.listValues.some(value =&amp;gt; this.listValues.includes(value));\n    }\n\n\n\n  The set is mutable, however, we can create immutable frozenset objects initialized with elements of the given iterable. Which is a set that does not change after being build. In Python, we can use the frozenset () function to create this structure.\n\n\nlist = (1, 6, 7, 4, 9, 6, 2, 3, 5) \nfrozenSet = frozenset(list) \n\n\nVery cool and easy to understand, right? üòÅ\n\n‚óºÔ∏è MultiSet\n\nThe Multiset structure or Bag is quite similar to set structure that we have learned before, but the difference is due to the fact that unlike the set structure allows more than one instance of the element in the structure.\n\nAn amazing thing that about programming it that there are many ways to develop the Multiset, we can continue using an array to store the values, or tuples if you are developing in Python.\n\nThis structure has the following properties:\n\n\n  items: List of element that contains the data and key.\n  multiplicity: Property which is a positive integer that gives how many elements has in the Multiset.\n  cardinality: Summing the multiplicities of all its elements.\n\n\nSince multiset is a type of set generalization, there are several ways to apply it to problem solving, Fuzzy multisets and Rough multisets, are some examples.\n\nNow that we already know what Multiset is, let‚Äôs create the main operations, which are: insert and remove.\n\n     insert(key, cardinality = 1){\n        try{\n            if(key == null || cardinality == null){\n                throw new Error(&#39;Is not possible to insert a null value&#39;);\n            }\n            var flag = true;\n            var listKeys = Object.keys(this.items);\n            listKeys.forEach(item =&amp;gt; {\n                if(item == key){\n                    this.items[key] = this.items[key] + cardinality;\n                    flag = false;\n                    this.cardinality = cardinality;\n                }\n            });\n            if(flag){\n                this.items[key] = cardinality;\n                this.cardinality = cardinality;\n            }\n        }\n        catch (error) {\n            return error.message;\n        }   \n    }\n\n    remove(chave, cardinality){\n        if(this.items[chave]){\n            var value = this.items[chave];\n            if(cardinality &amp;gt; value){\n                this.items[chave] = 0;\n            }else{\n                this.items[chave] = value - cardinality;\n            }\n        }\n    }\n\n\nWe can use the hash table in our Multiset structure, that is to say, the time complexity is always a constant O(1) to add or search an element. As you can imagine this structure has the same functions as the set, however, there are some differences that we are going to learn together. ü§ì\n\nThe algebra operations such as union, sum, intersect and difference have similar logic applies as the previous methods described before, so I‚Äôll skip the code explanation of them to not waste our time and only discuss about the difference.\n\n\n  Union\n\n\nThe main difference in the union of two multiset is that each element has the number of instances equal to the maximum of the multiplicity in A and B.\n{1, 2, 2} ‚à™ {2, 2, 3} = {1, 2, 2, 3}.\n\n\n\n  Sum\n\n\nIn this operation the intersection of two multisets is equal to the sum  of the multiplicity of an element in A and B.\n{1, 2, 2} + {2, 2, 3} = {1, 2, 2, 2, 2, 3}\n\n\n\n  Intersect\n\n\nThe intersection of two multisets is equal to the minimum of the multiplicity of an element in A and B.\n{1, 2, 2} + {2, 2, 3} = {2, 2}\n\n\n\n  Difference\n\n\nThe difference of two multisets is equal to the multiplicity of the element in A minus the multiplicity of the element in B.\n{1, 2, 2} + {2, 2, 3} = {3}\n{2, 2, 3} ‚àí {1, 2, 2} = {1}\n\n\n‚óºÔ∏è Conclusion\n\nIn conclusion, the most important factor that make the set structure special and unique comparing with the others is that use the core set-theoretical operations defined by the algebra of sets, which allows the use of properties and laws of sets using operation such as union and intersection. In this post we have a brief discussion about this operations.\n\nWe have learned that sets can be implemented using various data structures but the most common approach is using array or hash table. Even though the set structure looks like a simple structure there are many languages now include it can be applied in diverse scenarios and different generalizations, such as Fuzzy multisets, rough multisets and in relational databases.\n\n\n\nThat‚Äôs all folks! I hope you have fun learning the set structure üòÅ\n\nCode: https://github.com/FernandoBLima/data-structures\n\n\n  \n    \n      &amp;lt; previous\n      next ( coming soon) &amp;gt;\n    \n  \n\n\n\n\nSo we finished our discussion about Set and Multiset data structure. üôå\n\nI hope you have a clear idea how to work. If you found this article helpful or if you find something I miss out or that you like it, feel free to let me know. üòÅ\n\n"
} ,
  
  {
    "title"    : "Dictionary and HashTable -‚Ää Data Structure &amp; Algorithms Part II",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2019/11/25/data-structure-part-II.html",
    "date"     : "November 25, 2019",
    "excerpt"  : "Continuing our journey in the data structure and algorithms in a galaxy far, far away... \n\nIn the previous post, we had learned about linked list, queue and stack. Now we will continue our journey and move on to covering the Dictionary and HashMap...",
  "content"  : "Continuing our journey in the data structure and algorithms in a galaxy far, far away... \n\nIn the previous post, we had learned about linked list, queue and stack. Now we will continue our journey and move on to covering the Dictionary and HashMap data structure.\n\n\nIn this post, I will try to help you to understand these data structure. Once again, I will use JavaScript code examples; however, the main goal is not to go deeper in the language, but to try to demonstrate what makes these structures unique. You can find this structure implemented in several languages such as Python, JavaScript and so on and also in various algorithms, so understanding the structure behind the code it‚Äôs important, because what is the point of just learning code?\n\n\n  üí≠ ‚ÄúYou Can‚Äôt Write Perfect Software. Did that hurt? It shouldn‚Äôt. Accept it as an axiom of life. Embrace it. Celebrate it. Because perfect software doesn‚Äôt exist. No one in the brief history of computing has ever written a piece of perfect software. It‚Äôs unlikely that you‚Äôll be the first. And unless you accept this as a fact, you‚Äôll end up wasting time and energy chasing an impossible dream.‚Äù \n‚Äï Andrew Hunt, The Pragmatic Programmer: From Journeyman to Master\n\n\nOutline\n\nThe article is divided into the following parts:\n\n\n  Understanding what is Dictionary and Hash table.\n  How important is a hash function.\n  Code implementation and complexity analysis.\n  What is factor load.\n\n\n‚óºÔ∏è Dictionary\n\nDictionary, which some people prefer refer as map structure, is a collections of pairs [key, value] of distinct elements that use a key to find a value. A little bit confusing, right? I will try to explain in a different way.\n\nAs the name suggest this structure is like a dictionary book, where we can use as an example of being applied to a real-world when you search and found a word followed by his definition. üìö In our case, the word is the key and the description is the value stored.\n\nAt first, you might be wondering if there is some way we can use what we had learned in the last post and use the linked list to create this structure, right? Of course! We can use but we have to adapt the structure adding the key property because a linked list add a new element at the beginning of the list, resulting in an O(1) complexity of time. If we want to delete some value, we need to search the key and as you can remember, is not so efficient. So how we can build this structure? Programming is a kind of magic and we can implement in different ways, let&#39;s discover together! üßê\n\n‚óºÔ∏è Bucket array\n\nAs we saw, the linked list couldn‚Äôt be used; on the other hand an array can solve our problem. However, do you know what an array is? It is a collection with N elements where each position, called as bucket, in the array can have a value stored. I will try to illustrate in the following figure an array with an element at position 8.\n\n\n\nFigure 1: An array illustration\n\nIn a bucket array, we can use a key to identify any value stored, like a dictionary book. To get a better understanding of how it works why not create an example to store a key-value pairs. Suppose we have an array and we want to add some value let‚Äôs take a look at the example:\n\nvar bucketArray = [];\nkey = 1;\nvalue = &#39;Darth Vader&#39;;\nbucketArray[key] = value;\n\n\nYeah! We got it! üôå It was added the value in to our array using a key. The element stored in the hash table is quickly retrieved using the key. We can add, delete and search the pair value [key, value] with the O(1) constant time. Great! All the problems were solved, right? No, unfortunately. ‚òπÔ∏èü•∫\n\nLook at the following example assuming that both of our keys has the same value in this case 1.\n\nvar bucketArray = [];\n\nkey = 1;\nvalue = &#39;Darth Vader&#39;;\nbucketArray[key] = value;\n\nkey = 1;\nvalue = &#39;Obi Wan Kenobi&#39;;\nbucketArray[key] = value;\n\n\nDo you know what happens when the value ‚ÄòObi Wan Kenobi‚Äô is added using a key that already have being used? Collision! üí• And bug! üêû We can‚Äôt add the value because the key has to be unique.  With this in mind the bucket array didn‚Äôt resolve all our problems. ‚òπÔ∏è\n\n\n\n‚óºÔ∏è HashTable\n\nWe don‚Äôt need to be hurry about that! We can create a function to convert the key in an integer to resolve and handle our problem. Then using the hash value created we can use as an index in our array to avoid the collisions and that is what makes the hash table particularly useful. Is it confused? I will try to explain.\n\nWe need to keep in mind that the hash table is another approach to implement the dictionary data structure and the difference between them is by the fact how we can store and access data. Just remember that a hash table is composed with two parts, an array and hash function.\n\n\n\n Figure 2: A example of hash table \n\nTalk is cheap. Show me the code! üòÅ Our main hash table class would looks something like this:\n\nclass DumpHashTable {\n    constructor() {\n        this.list = {};\n        this.length = 0;\n    }\n}\n\n\n\n  Hash Function\n\n\nIn order to understand hash table we first need to know what the purpose of hash function is. As I said before, the main goal in a hash function is to convert a key in an integer and try to minimize the collision that can happen when we are adding a new value in the array.\n\nIn this function, the key is the input parameter and has a range between 0 and infinite and we need to distribute the keys uniformly across an array. It is necessary to reduce the value of the key and compress in the map function to convert in a range between 0 and N - 1, where N is the length of our array. Suppose we have an array of size 10 and our key has the value 23, it doesn‚Äôt fit because the value is larger than the size. Therefore, we need to compress the key into the size of the array.\n\nhash(x) : x ‚Üí {0, 1, 2, N ‚àí 1}\n\nThere are many ways to achieve a good hashing mechanism, let‚Äôs take a look in the most common function, the modulo operation.\n\n\n  Mod\n\n\nSuppose our array has length N and we need to add a new value. Then is necessary to convert the key into the array size using the mod operation, which result in the hash value, right?\n\n hash(x) = x mod N \n\nHowever, we cannot choose a random number to be used in the mod operation because we want to avoid clusters. If we choose a small number or a hash value that has many multiples we will get similar values, and as a result, the hash table will not be distributed. Let‚Äôs consider a table of size 24 and assuming we have a set of keys between 0 and 100 in a uniformly random distribution.\n\n ùêæ = {0,1,...,100} \n\nEvery number in ùêæ that has a common factor with the number 24 will be hashed as multiple of this factor; in this case, the factors of 24 are 1, 2, 3, 4, 6, 8, 12 and 24. That is to say, the values won‚Äôt be spread over all possible value between 0 and the array size.\n\n24 % 24 = 0\n48 % 24 = 0\n72 % 12 = 0\n\n\nWe can use a large prime number to avoid this problem, using a value we can spread more the hash values over all possible index between 0 and the array size, and as consequence, every value stored in the array will be within the range of prime number.\n\nTo minimize collisions it is important to reduce the number of common factors and choosing a prime number is how we can deal with because are the only number that have two different dividers: 1 and itself. For instance, let‚Äôs take a closer look in the following image where 100000 values were generated between the range {0,1,‚Ä¶,1000} in a normal distribution using 97 and 100 mod value. Can you notice which one is the best option?\n\n\n  \n    \n      \n      \n    \n  \n  \n    \n      ¬†\n      ¬†\n    \n  \n\n\n Table 1: Comparing a hash function using a normal distribution using 97 and 100 mod value\n\nWe can have the same result using uniform, triangular and exponential distribution.\n\n\n  \n    \n      \n      \n      \n    \n  \n  \n    \n      \n      \n      \n    \n    \n      UNIFORM\n      TRIANGULAR\n      EXPONENCIAL\n    \n  \n\n\n Table 2: Comparing others distributions using 97 and 100 mod value\n\nAllright, now that we understand how deal with hash function; we can see how our hash function would be considering the last example given:\n\nhash(data){\n   return data % 97;\n}\n\n\nWe also can use a string instead a number to use as the key, we just need to sum of the ASCII values of the characters in our string as we can see\n\nhash(data){\n    var hashTable = 0;\n    for(var i = 0; i &amp;lt; data.length; i++){\n       hashTable += data.charCodeAt(i);\n    }\n    return (hashTable) % 97;\n}\n\n\n\n  Another common hashing mechanism is the MAD (Multiply, Add, Divide).\n\n\n‚óºÔ∏è Collision Handling\n\nEven though we use some hash function sometimes it is almost impossible to create a uniform random distribution to avoid collisions. Therefore are many ways to handling collisions, as we can see below.\n\n\n  Separate chaining\n\n\nWe use this method when the key is already used, which means it is impossible to store a new value. We can handle this situation creating in the index a point to a linked list structure to store the new value into our array, in this way; the number of keys can exceed the size of the hash table. Nevertheless, is required more space to store the keys using the linked list, and at the same time, some buckets could be never used, which leads to wasted space.\n\nIn addition, using a linked list bring us to the disadvantage of searching and deleting values and to minimize this problem is common to limit the number of values that can be inserted in the linked list. The worst scenario of separate chaining is when all values are inserted at the same index and all the keys will be in only one linked list. To give an illustration of this approach, let‚Äôs look at the following image.\n\n\n\n Figure 3: Using separate chaining approach to handle collision in hash table. \n\n    insert(value) {\n        var key = this.hash(value); \n        let indexHash = new IndexHash(value, key);\n        if(this.list[key]){\n            indexHash.next = this.list[key];\n        }\n        this.list[key] = indexHash;\n        this.length++;\n    }\n\n‚óºÔ∏è Open addressing\n\nAnother way to improve the hash function is using the open addressing approach. On contrast of separate chaining, all values are stored in the bucket array and the hash table can never exceed the size. There are different ways to implement and the most common approaches are:\n\n\n  Linear Probing\n\n\nOur hash function that we are working on it happens to have collision on the index; one way to resolve is increasing the index and check if the next element on the bucket array is available to insert the new value.\n\n hash(key) = (hash(key) + i) mod N \n\nThe probing sequence for linear probing will be:\n\nnewIndex = (index + 0) % hashTableSize \nnewIndex = (index + 1) % hashTableSize \nnewIndex = (index + 2) % hashTableSize \nnewIndex = (index + 3) % hashTableSize \nand so on‚Ä¶\n\nWe have to iterate the array to check if the index of hash value of the ‚Äòhash(key) + i‚Äô is available. We can see how it works:\n\n    insert(value) {\n        try{\n            var key = this.hash(value);\n            key = this.proibingHash(key, value);\n            let indexHash = new IndexHash(value, key);\n            this.list[key] = indexHash;\n            this.length++;\n        }\n        catch (error) {\n            return error.message;\n        }   \n    }\n\n    proibingHash(key){\n        if(this.list[key] == null){\n            return key;\n        }else{\n            let flag = false;\n            let index = 1;\n            do{\n                if(index &amp;gt;= this.ARRAY_LENGTH || this.length == this.ARRAY_LENGTH){\n                    throw new Error(&#39;Error! Array size exceeds&#39;);\n                }else{\n                    let indexTable = index;\n                    indexTable = key + indexTable;\n                    if(this.list[indexTable] == null){\n                        flag = true;\n                        index = indexTable;\n                    }else{\n                        index++;\n                    }\n                }\n            }while(flag == false);\n            return index;\n        }\n    }\n\n\nIn proibingHash function, we iterate the array to check if the next index is available and if the size is exceed. It is important to say that the remove function has a similar logic of insert function, as we can see in the code bellow:\n\n    remove(value){\n        if(value == null){\n            return false;\n        }\n        var key = this._hash(value);\n        key = this.removeProibingHash(key, value);\n        if(this.list[key]){\n            this.list[key].value = null;\n            this.length--;\n            return true;\n        }else{\n            return false;\n        }\n    }\n\n    removeProibingHash(key, value){\n        if(this.list[key] &amp;amp;&amp;amp; this.list[key].value == value){\n            return key;\n        }else{\n            if(this.list[key] == undefined){\n                return null;\n            }\n            let flag = false;\n            let index = 1;\n            do{\n                if(index &amp;gt;= this.ARRAY_LENGTH || this.length == this.ARRAY_LENGTH){\n                    return false;\n                }else{\n                    let indexTable = index;\n                    indexTable = key + indexTable;\n                    if(this.list[indexTable] &amp;amp;&amp;amp; this.list[indexTable].value == value){\n                        flag = true;\n                        index = indexTable;\n                    }else{\n                        index++;\n                    }\n                }\n            }while(flag == false);\n            return index;\n        }\n    }\n\n\n\n  ‚ö°Ô∏è If you would like to know how I implemented, you can access the code just clicking here.\n\n\n\n  Quadratic Probing\n\n\nOkay, we talked about how linear probing can be useful, but let‚Äôs spend a minute to talk about the disadvantages of this approach. The biggest problem is the fact that can occur clusters when many elements are in the consecutive array index. Just imagine the following scenario where our bucket list has more than 1 million of element and we need to add a new element which index already was stored.\n\nConsequently, we have to go through many indexes to find an empty space in the array. Can you see that linear probing is not so efficient? It could take time to search an element or find an empty bucket. The biggest problem is when clustering of values in our array occur. We might want to solve this problem using a different probing approach, which lead us to the quadratic probing. Instead, add the index we have to add the power of the original index.\n\n hash(key) = (hash(key) + I^2 ) mod N \n\nThe sequence will be:\n\nnewIndex = hash(key) % hashTableSize \nnewIndex = (hash(key) + 1^2 ) % hashTableSize \nnewIndex = (hash(key) + 2^2 ) % hashTableSize \nnewIndex = (hash(key) + 3^2 ) % hashTableSize \nand so on‚Ä¶\n\nOn the other hand, depending on the size of the array an infinite loop may be created and not able to add the new element.\n\n\n  Double Hashing\n\n\nHere we have a different approach comparing to linear and quadratic probing, because a secondary hash function is used as a fixed increment in the jump distance, an advantage is that we can use a unique jump value.\n\n hash(key) = (hash1(key) + j hash2(key)) % hashTableSize \n\nWhere j is the index, the probing sequence will be:\n\nnewIndex = (hash1(key) + 1 * hash2(key)) % hashTableSize; \nnewIndex = (hash1(key) + 2 * hash2(key)) % hashTableSize; \nand so on‚Ä¶\n\nFurthermore, as we can see the open addressing, such as linear, quadratic and double hashing has almost the same drawback and we cannot exceed the number of spaces in the bucket array.\n\n‚óºÔ∏è Time complexity\n\nIn general, we can say that the time complexity in big O notation is:\n\n\n   Algorithm    | Average                       |   Worst case                         \n----------------|-------------------------------|----------------------|\n Search         | O(1)                          | O(n)                 |\n Insert         | O(1)                          | O(n)                 |\n Delete         | O(1)                          | O(n)                 |\n\n\n Table 3: The time complexity of Hash table\n\n‚óºÔ∏è Load Factor\n\nNow we will discuss the relationship between the number of entries and buckets, the load factor, which is equal to the number of elements divided by the number of buckets.\n\n\n\nIt is expected to have emptier bucket to accommodate all the elements that we inserted in our bucket, resulting in a load factor less than 1. When is more than 1 is necessary to rehashing, which means to increase the number of buckets and change the hash function, otherwise, the element can‚Äôt be add into our array.\n\n‚óºÔ∏è Conclusion\n\nThat‚Äôs it! The Hash table is an extended topic and is almost impossible to cover everything in just only one article. However, as we can see, it is crucial to understand how and why the data structure is used, even though a linked list could be used to create a structure of collections of pairs [key, value] of distinct elements, the result won‚Äôt be so efficient.\n\nWhich makes us to use the bucket array that have the speed advantage, where we can access a value in a constant time O(1), however, many values can be added resulting in collisions. We have learnt that there are many ways to build a hash function to avoid this behavior but sometimes is almost impossible to create a perfect function, which can make this structure quite inefficient when many collisions occur. As consequence, some approaches were developed to try to solve or handle this issue but each one has advantage and drawbacks.\n\nAll of this points to the conclusion that by comparing the approaches we can see that we do not have a better one, because depend on context and other factor, such as where an extra space is needed or not, or even whether the number of keys to be stored cannot be exceeded, for instance.\n\n\n\nThat‚Äôs all folks! Now that we had a chance to discuss this data structure I hope you keep coding and having fun. ü§ì\n\nCode: https://github.com/FernandoBLima/data-structures\n\n\n  \n    \n      &amp;lt; previous\n      next ( coming soon) &amp;gt;\n    \n  \n\n\n\n\nSo we finished our discussion about Dictionary and Hash Table data structure. üôå\n\nI hope you have a clear idea how to work. If you found this article helpful, if you find something I miss out or that you like it, feel free to let me know. üòÅ\n\n\n"
} ,
  
  {
    "title"    : "Linked List, Queue and Stack‚Ää-‚ÄäData Structure &amp; Algorithms Part I",
    "category" : "",
    "tags"     : " Algorithm, Data Structure, Javascript",
    "url"      : "/2019/10/25/data-structure-part-I.html",
    "date"     : "October 25, 2019",
    "excerpt"  : "Learning the concepts and how to implement Linked List, Queue and Stack.\n\nWelcome to my first article where I going to talk about Data Structures. I‚Äôm so excited to be writing this series! It‚Äôs my first article here and I have been postponed this ...",
  "content"  : "Learning the concepts and how to implement Linked List, Queue and Stack.\n\nWelcome to my first article where I going to talk about Data Structures. I‚Äôm so excited to be writing this series! It‚Äôs my first article here and I have been postponed this for so a long time and many reasons, maybe I can write about it another time, but finally I decided to complete this goal.\n\n\n\nHere I will show how important this topic is and why you should understand all the concepts. In my point of view is important to know the concepts and how it works behind the scenes, although there are many frameworks that already have the complete implementation. But, trust me, it is essential for your career and maybe you may need it in the future to resolve some problem. üë®‚Äçüíªüë©‚Äçüíª\n\nHere we are going to have a brief discussion with Javascript examples and I will start from the beginning, gradually, because we do not have to be hurry! So, let‚Äôs diving in this fantastic world called data structure and algorithms together. üòÄ\n\nüí≠ ‚ÄúBad programmers worry about the code. Good programmers worry about data structures and their relationships.‚Äù‚Ää-‚ÄäLinus Torvalds\n\nOutline\n\n\n  Discussion about Singly, Doubly and Circular Linked List.\n  What is a Queue and Stack?\n  Terminology.\n  When and where is used?\n  Code implementation and complexity analysis.\n\n\nWhat is a Linked List?\n\nBefore we start to discuss, we need to formulate a clear understanding of what a linked list is. A collection structure represents a sequence of nodes. But, wait! ‚úã What does node mean? ü§î  An object that contains value and pointer with reference to stores the address for the next element into the sequence of the list, as you can see in the following figure:\n\n\nFigure 1: Linked List representation.\n\nActually, you can imagine a pointer, as a place where you can find and obtain the stored value in the node, is a reference to a location in memory. The first node in the list represent a head and has a pointer to the next element, and as you can imagine the last node is the tail because has a null pointer to the next node.\n\n\n   You also can use a pointer to the previous object. As a result, a Doubly Linked List type is created.\n\n\n\nAnother important aspect to understand linked list is related to the efficient memory utilization. Is not necessary to pre-allocate memory, as a consequence you can add as much items you want in the list. However, some problems can show up if is required more memory than you can have, because each node has a pointer and other memory for itself.\n\nTerminology\n\nAs you can see in the image in the section above, we define two properties:\n\n  value: Element that holds the data.\n  next: Point to the next node.\n\n\n\n  \n    prev (optional): Can be used to point to the previous node. You can see more about in Doubly Linked List Structure.\n  \n\n\nLet‚Äôs begin!\n\nNow that we are on the same page with the concepts, let‚Äôs start the discussion more deeply about Linked List methods, translate the concepts into to our code, and finally implement our data structure. At the beginning, we are going to focus in the Linked List, because it is the most common and simplest data structure linear collection of data elements.\n\nLet‚Äôs start to work! üòÉ\n\n‚óºÔ∏è Singly Linked List\n\nIs called as singly because a node only hold a reference to the next element of the sequence and you cannot access previous elements because it does not store any pointer or reference to the previous node, as you can see in the figure.\n\n\nFigure 2: A singly linked list that contain an element and a pointer to the next node\n\nBefore we describe the operations, we need to define the most important part in our code that will help us to build the linear list structure, the node class.\n\nclass Node {\n   constructor(value, next) {\n      this.value = value;\n      this.next = next;\n   }\n}\n\n\nOur main class only has a reference to the value and the next node, pretty simple, right? So, let‚Äôs move on and define the Linked List class, which has the head property that point to the first element into the list, other property we have to declared is the size, which give to us the number of nodes that exist into our list.\n\nclass LinkedList {\n    constructor() {\n       this.head = null;\n       this.length = null;\n    }\n}\n\n\nOkay, continuing the discussion we have to add methods to our class. Let‚Äôs check out:\n\n\n  insertAtHead: Our first method is used to add a new element at the beginning of our data structure. This method has a constant running time (O(1)). But what does it mean? üßê It means that it takes the same amount of time to add a value in the list, is a constant time. In this case is necessary only to move one time to add a new element in the first position into the list. As result, we need to update only the current head that will be pointing to the new item that we are going to be creating. Here‚Äôs how it should be:\n\n\naddToHead(value){\n   if(linkedList.head){\n      var newNode = new Node(value, this.head );\n      this.head = newNode;\n   }else{\n      var newNode = new Node(value, null);\n      this.head = newNode;\n   }\n   this.length++;\n}\n\n\n\n  removeAtHead: If we want remove one element from the head all we have to do is replace the head by the following element. Like the method before the constant running time is O(1).\n\n\nremoveAtHead(value){\n    if(this.head){\n       var newHead = this.head.next;\n       this.head = newHead;\n       this.length--;\n    }else{\n       return false;\n    }\n}\n\n\n\n  search: If we are looking for a specific item? Do not be hurry; we only need iterate the list until the end to find the element in the list. But imagine the following scenario: We have a list with 1000 items and we are looking for the 999 item. Can you guess what can happen? If we want to get some specific value or node at position N then we have to moving the pointer throw the entire list to find it. This can cause a problem with the access time.\n\n\n    search(value){\n        if(this.head){\n            var node = this.head;\n            var count = 0;\n            while(node != null &amp;amp;&amp;amp; node.value != value){\n                if(count &amp;gt;= this.length &amp;amp;&amp;amp; node.value != value){\n                    return false;\n                }\n                node = node.next;\n                count++;\n            }\n            if(node == null){\n                return false;\n            }else{\n                return true;\n            }\n        }else{\n            return false;\n        }\n    }\n\n\nThere are others functions like getAtIndex, addAtIndex, removeAt and reverse that I would like to discuss, but they have similar logic applies as the previous methods described before, so I‚Äôll skip the explanation of them to not waste your time.\n\n\n  ‚ö°Ô∏è But if you would like to know how I implemented, you can access all the code just clicking here. \n__\n\n\n‚óºÔ∏è Doubly Linked List\n\nAs I mentioned earlier, the Doubly Linked List is a structure that has capacity to pointer to the previous node, which is the biggest difference comparing with the Singly List. Now we gain the power to move traversed backward in the list. For instance, each node has a pointer to the previous element, allowing you to move through the list from the tail, as show in the picture below.\n\nAs Uncle Ben said to Peter Parker, ‚Äúwith great power comes great responsibility‚Äù. As consequence, is required more space to store the addresses of previous elements instead just one to the next element in list, so takes two more memory comparing with the singly structure.\n\nBesides that, mostly all functions and behaviors are quite similar with the Singly List. With basic understanding of Linked List, it is so easy to build and extend functionality to make it a Double List. So easy, right? üòÅ You can feeling that we are having progress. üí™\n\n\n\nFigure 3: A doubly linked list with pointer to the previous element\n\nEven though the behavior is similar, we need to update the Singly List functions such as addAtHead, removeAtHead, search and others to consider the previous property. Besides these functions, we have new weapons to use here, as you can see below:\n\n\n  insertAtTail: We define a new element at the bottom of the list and point the last element as the tail. Can you imagine the constant running time?\n\n\n    addAtTail(value){\n        var newNode = new Node(value, null, this.tail);\n        if(this.tail){\n            this.tail.next = newNode;\n            this.tail = newNode;\n        }else{\n            this.head = newNode;\n            this.tail = newNode;\n        }\n        this.length++;\n    }\n\n\n\n  removeAtTail: Here the last item from the list is set to the null value. As a result, the final element become the previous element of the last element.\n\n\n    removeAtTail(){\n        if(this.length === 1){\n            this.removeAtHead();\n            this.tail = null;\n            return;\n        } else if (this.length &amp;gt; 1){\n            this.tail = this.tail.prev;\n            this.tail.next = null;\n            this.length--;\n            return;\n        }\n        return false;\n    }\n\n\n‚óºÔ∏è Circular Linked List\n\nThe only difference between the doubly Linked List is the fact that the tail element is linked with the first element in the list. As a result, a loop was created and now we can move forward and back-forward into the entire list.\n\n\nFigure 4: Circular linked list that contain a link between the first and last element.\n\nNow we will use the entire acknowledgement that we learned to implement two new data structure.\n\n‚óºÔ∏è Queue\n\nThe First-In-First-Out (FIFO) is an example of a linear data structure where the first element added to the queue will be the first to be removed. For instance, you can visualize this behavior where you are in a queue in a store, bank or supermarket.\n\nüö∂‚Äç‚ôÇÔ∏èüè¶üö∂‚Äç‚ôÄÔ∏èüö∂‚Äç‚ôÇÔ∏èüö∂‚Äç‚ôÄÔ∏èüö∂‚Äç‚ôÇÔ∏è\n\nA new element is added to the end of the list by the enqueuer (addFromTail) function and removed from the top of the list using the dequeue (removeFromTail) function. You can see other people or find in a book referencing the queue as removing or poling method, for me I prefer only dequeue. Other common operation in this structure is the peek that return the item at the top of the stack as peek.\n\nHowever, when should I use these structure data? ü§î It is suggested to use Queue when the order matter, like a queueing system for requests.\n\n\nFigure 5: Representation of a Queue.\n\n‚óºÔ∏è Stack\n\nKnown as LIFO (last in, first out) data structure, you can visualize understanding how it works making an analogy when a set of items is stacked on top of each other, creating a pile of books.\n\nLike I said before, this structure has some similarities from Linked List and you can use addFromTail (Push) and removeFromTail (Pop) operations in your stack structure. Just like a queue, the operation that return an item at the top of the stack is called as peek.\n\nYou can find this structure in mechanisms in text editors, compiler syntax checking or also on a graph.\n\n\nFigure 6: A representation of a stack and the Push and Pop functions.\n\n\n\n‚óºÔ∏è Time Complexity\n\nYou can see the time complexity in the image below, where n is the length of Linked List.\n\n\nFigure 7: The time complexity.\n\nLet‚Äôs create an example by adding some values in the head and then removing in a Linked List using addAtHead and removeAtHead functions. In addition, using the time() object in Javascript will allowed us to time and analyzes the performance of our code, as the follow figure:\n\n\nFigure 8: Output after insert and remove some values in the Singly Linked List.\n\nAs you can see, we add some values in the list that show us how faster it is. Seeing the values we can realize that the execution time become a constant. The image below show the plot using Python with the Panda DataFrame library.\n\n\nFigure 9:  The consume time between addAtHead and removeAtHead functions.\n\nWe are done üôå\n\n‚óºÔ∏è And that‚Äôs it!\n\nTo sum up our brief discussion, we have learnt that the Linked List is a simplest and dynamic data structure that can be used to implement others structures such as Queue and Stack.\n\nYou can use these structures to perform a huge amount of insertion and deletion of items. It run fast by the fact that we need update only the next pointer in the node. However, if we want to get some specific value or node at position N, a problem with access time may occur if the size of the list is longer.\n\nOther important factor is the efficient memory utilization, it not necessary to pre-allocate memory. Nevertheless, in case you need more space, a problem related to a contiguous block of memory can occur.\n\nThat‚Äôs all folks!\n\nCode: https://github.com/FernandoBLima/data-structures\n\n\n  \n    \n      next ( coming soon) &amp;gt;\n    \n  \n\n\n\n\n"
} 
  
  
  
]
